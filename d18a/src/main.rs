mod dijkstra;
use crate::dijkstra::*;
use std::vec::Vec;
use std::char;
use std::collections::HashMap;

const INPUT: [&str; 81] = [
	"#################################################################################",
	"#...........#.......................#...#.........#.....#.....#...Q.............#",
	"###.#######.#################.#.###.###G#.#####.#.#.#.###.#.#.#.#######.#####.###",
	"#...#.......................#.#.#.......#...#...#z#.#...#.#.#.#...#u..#....b#...#",
	"#.#########################.###.#######.###.#.#####.###.#.#.#####.#.#.#####.###.#",
	"#.............#...#l....#.#...#.....#.#.#...#...#...#...#.#.....#.#.#...#...#...#",
	"#.###########.#.###.#.#.#.###.#####.#.#.#######.#.###.#N#.###.###.#.###.#####.#.#",
	"#.#.........#.#.....#.#.....#.#.....#...#.......#.#.#.#.#...#...#.#...#.......#.#",
	"#.#.#######.#.#.#####.#####.#.#.#####.###.#####.#.#.#.#####.###.#.###.###########",
	"#.#.#.D.#...#.#.....#.....#.#.#.....#...#.#.....#...#...#...#...#...#...#.......#",
	"#.#S#.###.###.#####.#####.#.#.#####.###.#.#.#######.###.#.###.#.###.###.#.#####.#",
	"#...#.......#.#...#.#...#.#.#.#...#.#.#.#.#.#.......#.#.....#.#.#.....#...#.#.A.#",
	"#.###########.#.#.#.#.###.#.#.#C#.#.#.#.#.#.#.#######.#######.###.#######.#.#.#.#",
	"#.#.........#.#.#.#.#.#...#.#...#...#.#.#.#.#...#.#.....#.#...#...#...Y.#...#.#.#",
	"#.#.#######.#.#.###.#.#.#############.#.#.#####.#.#.#.#.#.#.###.###.###.###.#.###",
	"#.#.#...#.#...#...#...#.........#.....#.#.....#.#...#.#.#.#.......#.#.#.#...#...#",
	"###.#.#.#.#######.###.#####.###.#.#.###.#.#.#.#.#####.#.#.#########.#.#.#######.#",
	"#...#.#...#.......#.....#...#.#.#.#.#...#.#.#.#.#.....#...#...#m..#...#.#.....#w#",
	"#.###.###.#.#.#####.#####.###.#.#.#.#.###.#.#.#.#.#.#######.#.#.#.###.#.#.###.#.#",
	"#e..#...#...#.#.......#...#.....#.#.#...#.#.#.#...#.#...F...#...#.#...#.#...#...#",
	"#.#.###.#######.#######.#.#####.###.###.#.#.#.#####.#.###########.#.###.#.#.###.#",
	"#.#...#...#.......#...#.#.#...#.......#.#.#.#.#.....#...#i..#.I.#.#.#y#.#.#.#.#.#",
	"#.###.#.#.#.#######.###.###.#.#######.#.#.#.###.#######.#.#.###.#M#.#.#.###.#.#.#",
	"#.#.#.#.#.......#...#.#.....#...#.....#.#.#...#...#.#...#.#.....#.....#x#...#.#.#",
	"#.#.#.#.#########.###.#.#######.###.###.#.###.###.#.#.###.#############.#.###.#.#",
	"#.#.#.#.#.#.....#.#...#...#...#...#...#.#v..#...#...#f..#.#...#..o#.....#.#...#.#",
	"#.#.#.#.#.#.###.#.#.#.###.#.#####.#####.#.###.#.###.###J#.#.#.#.#.#.#####.###.#.#",
	"#...#.#...#.#.#...#.#...#.#.#...#.#...#.#.#...#.#...#...#.#.#...#.#.#...#...#...#",
	"###.#.###.#.#.#####.#####.#.#.#.#.#.#.#.#.#.#####.###.###.#.#####.#.#.###.#.#.###",
	"#...#...#.#...#...#.........#.#...#.#.#.#.#.#.....#...#.#.#.#...#.X.#.....#.#...#",
	"#.#####.#####.#.#.#.#########.#####.#.#.#.#.#.#####.###.#.#O#.#.###########.###.#",
	"#.#...#.....#...#.#.....#...#...#...#.#.#.#...#...#.#..k#...#.#.....#.......#.#.#",
	"#.#B#######.#####.###.###.#.###.#.###.#.#.#####.#.#.#.###########.#.#.#######.#.#",
	"#.#.......#.....#.#...#...#...#...#...#.#...#.#.#..j#.....#.......#.#.#.......#.#",
	"#.#.#####.###.#.#.#####.#####.#.###.#.#.###.#.#.#######.#.#.#######.#.#######.#.#",
	"#.#...#.....#.#.#.......#.....#.#.#.#.#.#.#.#.#.#...#...#.#...#...#.#.....#...#.#",
	"#.#####.###.#.###########.#####.#.#.###.#.#.#.#K#.#.#.###R#.#T###.#.#####.#.###.#",
	"#.#...#...#.#.....#.....#.#...#.#.#...#.#.#.#.#.#.#...#...#.#.#...#...#...#...#.#",
	"#.#.#.###.#.#####.#.#.###.#.#.#.#.###.#.#.#.#.#.#.#####.#####.#.#####.#.###.#.#.#",
	"#...#.....#.....#...#.....#.#.......#.........#...#...........#.......H.#...#..p#",
	"#######################################.@.#######################################",
	"#...........#.....#.....#...#...#.....#.........#...#.......#...#...#...........#",
	"#.###.#####.###.#.#.#.#.#.#.#.#.#.#.#.#.#.#.###.#.#.#.#.###.#.#.#.#.###.#######.#",
	"#.#.#.#...#.....#.#.#.#.#.#.#.#...#.#...#.#.#...#.#...#...#...#...#...#.#.......#",
	"#.#.#.#.#########.###.#.#.#.#####.#.###.#.#.#.###.#######.###########.#.#.#######",
	"#.#.#.#.........#...#.#.#.#.....#.#...#.#.#.#...#.......#...#.#...#...#.#.#.....#",
	"#W#.#.#####.###.###.#.#.#.#####.#####.#.###.###.#######.###.#.#.#.#.###.#.#.###.#",
	"#...#.#...#...#...#.#.#.#.#.....#.....#.#...#...#........g#.#...#.#.#..s#.#...#.#",
	"###.#.#.#.###.###.#.#.#.#.#.#####.#####.#.#######.#######.#.#####.#.#.#####.###.#",
	"#...#.#.#.#t..#...#.#.#.#.#...#...#...#.#.#.......#...#...#.....#.#.#.......#...#",
	"#.###.#.#.###.#.###.#.#.#.###.###.#.#.#.#.#.#######.#.#########.#.#.#.#######.#.#",
	"#...#...#...#.#.....#.#.#...#...#.#.#...#...#.......#...#...#...#...#...#.....#.#",
	"###.#######.#######.#.#.###.###.#.#.#####.###.#########.#.#.#.###.#######.#####.#",
	"#.#.#.....#...#...#...#.#r#.#.#...#.....#.#.#...#.....#...#.#.#.#...#.....#.....#",
	"#.#.#.#######.#.#.#####.#.#.#.#########V#.#.###.#.###.#####.#.#.###.#.#####.#####",
	"#...#.#.....#.#.#.#...#.#.#.#.........#.#...#.#.#...#.#...#...#...#...#.#...#...#",
	"#P###.#.###.#.#.#.#.#.#.#.#.#.#####.###.###.#.#.###.#.###.#######.#####.#.#####.#",
	"#.....#.#.....#.#.#.#...#.#.#.....#.....#.#...#...#.#...#.#.............#.......#",
	"###.###.#####.#.#.###.###.#.#####.#######.###.###.#.###.#.#.#.#########.#######.#",
	"#...#...#...#.#.#...#.....#.#.#...#.....#.#.....#.#.#.....#.#.........#.....#...#",
	"#####.###.#.###.###.#######.#.#.###.###.#.#.#####.#.#######.#######.#.#####.#.###",
	"#.....#...#.......#.#.#.....#.#.#...#...#...#...#.#.......#.#.#...#.#.....#.#.#.#",
	"#.###.#.###########.#.#.#####.#.###.#.#######.#.#.#.#####.#.#.#.#.#.#####.###.#.#",
	"#...#.#.#.....#.....#...#.....#...#.#...#...#.#...#...#...#.#...#.#.#...#...#.#d#",
	"#.#.#.#.#.###.#.#########.#.#####.#.#####.#.#.#########.#.#.#####.#.#.#.###.#.#.#",
	"#.#.#.#...#.#.#...#.......#.#...#.#.#...#.#.#.........#.#.#.....#.#...#...#.#.#.#",
	"#.#.#######.#.###.#.#######.#.#.#.#.#.#.#.#.#########.#.#######.#.#########.#.#.#",
	"#.#.........#...#.#...#.L.#...#c#.#...#.#.#...........#....q..#.#.........#.....#",
	"#.#######.#####.#.###.###.#####.#.#####.#.#############.#####.#E#########.#######",
	"#.#.....#.......#...#.....#...#.#.#...#.#.#...#...#.....#...#.#.#.......#.......#",
	"#.#.###############.#####.###.#.#Z#.#.#.#.#.#.#.#.#.#####.###.#.#.#############.#",
	"#.#.......#.....#.#.....#.....#...#.#...#...#.#.#...#...#.U.#...#.....#.........#",
	"#.#.###.#.###.#.#.###.#######.#####.###.#.###.#.#####.#.###.#########.#.#########",
	"#.#...#.#.....#.....#.......#.#.....#.#.#.#...#...#...#.#.........#...#.#.#.....#",
	"#.###.#.###########.#######.#.#.#.###.#.#.#.#####.###.#.#.#######.#.#.#.#.#.#.#.#",
	"#.#...#a#.........#...#.#...#.#.#.#...#.#.#.....#.....#...#.....#...#.#.#...#.#.#",
	"#.#####.#.#####.#####.#.#.###.###.#.#.#.#.#####.#########.#.###.#######.#####.#.#",
	"#.#...#.#.#...#.....#...#..n..#...#.#.#.#...#.#.........#.#.#...#.....#.#...#.#.#",
	"#.#.#.#.#.#.#.#####.###.#######.###.#.#.###.#.#########.###.#.###.###.#.#.#.#.#.#",
	"#...#...#...#....h#.............#...#...#.............#.....#.......#.....#...#.#",
	"#################################################################################",
];

type Pos = (usize, usize);
type Grid = Vec<Vec<u8>>;
//type Nodes = HashMap;

const WALL: u8 = '#' as u8;
const WALL: u8 = '#' as u8;

fn is_path(grid: &Grid, pos: Pos) -> bool
{
	// '.', '@'
	grid[pos.1][pos.0] == 0x2E || grid[pos.1][pos.0] == 0x40
}

fn is_door(grid: &Grid, pos: Pos) -> bool
{
	// 'A' - 'Z'
	grid[pos.1][pos.0] >= 0x41 && grid[pos.1][pos.0] <= 0x5A
}

fn is_key(grid: &Grid, pos: Pos) -> bool
{
	// 'a' - 'z'
	grid[pos.1][pos.0] >= 0x61 && grid[pos.1][pos.0] <= 0x7A
}

fn is_wall(grid: &Grid, pos: Pos) -> bool
{
	// '#'
	grid[pos.1][pos.0] == 0x23
}

fn is_not_wall(grid: &Grid, pos: Pos) -> bool
{
	is_path(grid, pos) || is_door(grid, pos) || is_key(grid, pos)
}

fn find_nodes(grid: &Grid) -> (Vec<Pos>, Vec<Pos>, Vec<Pos>)
{
	let mut ret = Vec::new();

	for (y, row) in grid.iter().enumerate()
	{
		if y == 0 || y == grid.length() - 1
		{
			continue;
		}
		let len = row.length() - 1;
		for (x, ch) in row.iter().enumerate()
		{
			if x == 0 || x == len
			{
				continue;
			}
			if ch == WALL
			{
				continue;
			}
			// Something is a node if:
			//
			//   1) It has 3 or 4 adjacent non-walls.
			//   2) It has 2 adjacent non-walls, one of them a door or key.
			//   3) It is a door or a key.
			//
			if (grid[y - 1][x - 1] != WALL && grid[y - 1][x + 1] != WALL && grid[y + 1][x - 1] == WALL && grid[y + 1][x + 1] == WALL)
			|| (grid[y - 1][x - 1] != WALL && grid[y - 1][x + 1] == WALL && grid[y + 1][x - 1] != WALL && grid[y + 1][x + 1] == WALL)
			|| (grid[y - 1][x - 1] == WALL && grid[y - 1][x + 1] != WALL && grid[y + 1][x - 1] != WALL && grid[y + 1][x + 1] == WALL)
			|| (grid[y - 1][x - 1] != WALL && grid[y - 1][x + 1] == WALL && grid[y + 1][x - 1] == WALL && grid[y + 1][x + 1] != WALL)
			|| (grid[y - 1][x - 1] == WALL && grid[y - 1][x + 1] != WALL && grid[y + 1][x - 1] == WALL && grid[y + 1][x + 1] != WALL)
			|| (grid[y - 1][x - 1] == WALL && grid[y - 1][x + 1] == WALL && grid[y + 1][x - 1] != WALL && grid[y + 1][x + 1] != WALL)
			{
				// Exactly two adjacent paths.  Not a node.
			}
			else
			{
				// 1 or 3 or 4.
			}
		}
	}

	ret
}

fn test_keys(keys: &HashMap<u8, Pos>, doors: &HashMap<u8, Pos>, grid: &mut Vec<Vec<u8>>, pos: Pos) -> usize
{
	let adj = build_adjacency(grid);
	let d = dijkstra(pos, &adj);

	let mut min = std::usize::MAX;

	for k in keys.iter()
	{
		//println!("{}: {:?}", char::from_u32(*k.0 as u32).expect(""), d.get(k.1));
		match d.get(k.1)
		{
		None => {},
		Some(len) =>
		{
			// Remove the specified door and key, then recurse.
			let key = *k.0;
			let door = key - 0x20;
			let pos = doors[&door];
			// println!("{}: {:?}", char::from_u32(door as u32).expect(""), pos);
			//println!("==");
			let mut row = grid[pos.1].clone();
			row[pos.0] = 0x2E;
			let mut keys = keys.clone();
			let mut doors = doors.clone();
			keys.remove(&key);
			doors.remove(&door);
			//println!("{:?}", keys);
			//println!("{:?}", doors);
			//println!("{:?}", pos.1);
			
			grid.push(row);
			let row = grid.swap_remove(pos.1);
			
			let ret = test_keys(&keys, &doors, grid, pos);
			if ret < std::usize::MAX
			{
				let ret = ret + len;
				if ret < min
				{
					//println!("{:?}", min);
					min = ret;
				}
			}
			
			// Put the door back.
			grid[pos.1] = row;
		}
		}
	}

	min
}

fn main()
{
	let mut grid = Vec::new();

	let mut keys = HashMap::new();
	let mut doors = HashMap::new();
	let mut start = (0, 0);
	
	for (y, row) in INPUT.iter().enumerate()
	{
		let mut v2 = Vec::new();
		//println!("{:?}", row.as_bytes());
		for (x, ch) in row.as_bytes().iter().enumerate()
		{
			if *ch >= 0x61 && *ch <= 0x7A
			{
				//println!("({}, {}) = {}", x, y, char::from_u32(*ch as u32).expect(""));
				// Key.
				keys.insert(*ch, (x, y));
			}
			if *ch >= 0x41 && *ch <= 0x5A
			{
				// Door.
				doors.insert(*ch, (x, y));
			}
			if *ch == 0x40
			{
				// Start.
				start = (x, y);
			}
			v2.push(*ch);
		}
		grid.push(v2);
	}

	let ret = test_keys(&keys, &doors, &mut grid, start);
	//let adj = build_adjacency(&vec);
	//println!("{:?}", keys.clone());
	println!("{:?}", ret);
}

